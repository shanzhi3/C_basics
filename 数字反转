看到题目最先想到的是用除法把每一位数提取成数字，再按倒序排列转换成小数，
这样其实更麻烦，这道题这样做的关键在于float int double之间的转换，不进行数据转换会有精度问题
比如第18行，为了保证精度加上了0.5之后再做转换：浮点数在计算机中存储时可能会有精度问题，导致乘以 10 后的结果可能不是精确的整数。例如，123.4 * 10 可能会变成 1233.999999999 而不是 1234，加上0.5之后保证四舍五入后的精度
再比如26行，开始写的时候写的是k = 1 * d + 0.1 * c + 0.01 * b + 0.001 * a;不觉得1 * d和d有什么区别
问AI之后得出：
1 * d：这里的 1 是一个 int 类型的字面量，d 也是 int 类型。因此，1 * d 的计算结果是一个纯粹的 int。
int + double：接下来，这个 int 类型的结果与 0.1 * c 的结果相加。0.1 是一个 double 类型的字面量，所以 0.1 * c 的结果是 double。当 int 和 double 相加时，C 语言会将 int “提升”为 double，然后再进行计算。
后续计算：之后的所有加法都是在 double 类型下进行的。
虽然整个表达式最终都以 double 精度计算，但表达式的“开头”是一个纯整数运算。在某些编译器或计算环境下，这种“先整数，后浮点”的计算路径可能引入与其他写法不同的、极其微小的浮点误差。

当表达式以 d + ... 开头时，第一个加法操作就强制将整数 d 提升为了 double，使得整个求和过程从始至终都在浮点数（double）域中进行。

#include<stdio.h>
int main(){
    float x;
    scanf("%f", &x);
    int a, b, c, d;
    int t = (int)(x * 10 + 0.5);
    float k = 0;
    
    a = t / 1000;
    b = t % 1000 / 100;
    c = t % 1000 % 100 / 10;
    d = t % 1000 % 100 % 10;

    k = d + 0.1 * c + 0.01 * b + 0.001 * a;

    printf("%.3f", k);
    return 0;                                                                  
}
